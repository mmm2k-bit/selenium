Why do we need Xpath and CSS selectors?
=developers will not provide all the locators in html
= by using xpath and css selectors we can identify elements with nay given attribute;

What is an Xpath?
-- It's a query language which helps us to identify elements uniquely on the web page


Types of Xpath:
Absolute - starts first the starting node in html
it always starts with the single slash (/)
e.g. /html/body/div/div/div

open xpath fiels - command +F

Relative Xpath:
you can start relative xpath from any node in the HTML
Always starts with double slash (//)


Syntax for the relative Xpath:

//tagName[@attribute= 'Attribute value']  -- needs space after =

example:
//input[@id= 'email']

If we have text - identifying elements by text:

//tagname[text()= 'text value itself']

Example:
//a[text()= 'Create new account']

Identifying elments by using contains method

//tagName[contains(@attribute, 'partial attribute value')]

//input[contains(@placeholder, 'Email')]

Starts with will identify the element with partial starting value.
//tagName[starts-with(@attribute, 'partial starting attribute value ')]

Example:
//button[starts-with(@data-testid, 'royal')]


ends-with was used in Xpath 1.0 version. Now we are using Xpath 2.0 and this method not avail.

priority :
id
name
Xpath

-----------------

Tags

<div>  ===  division
<img>  === image
<h>  === header
<p>  === paragraph
<a>  === link OR anchor
<li>  === list
<ul> ===  unordered list
<ol> === ordered list
<br> === beraking line

================
Advanced Xpath
is based on the parent & child & sibling relationship

1. Identifying elements in advance Xpath by following siblings:
//tagName[@attribute= 'attribute value']/following-sibling::tagname

Example:
//input[@id= 'calFromDate']/following-sibling::img


2. Identifying elements by preceeding sibling:
//tagName[@attribute= 'attribute value']/preceding-sibling::tagname

//span[text() = '& Orders']/preceding-sibling::span

3, by parent

//span[text() = '& Orders']/parent::a

4. anthing above parent = is considered ancestor  -> identifying by ancestor
//tagName[@attribute= 'attribute value']/ancestor::ancestor tag name

//tagName[@attribute= 'attribute value']/preceding-sibling::tagname




If we have more than one element with the same identifier and need to find by indes:
(//img[@class = 'ui-datepicker-trigger'])[2]   - we put the xpath in brkets and speify the index
